from datetime import datetime
import utils
import os
import shutil

import logging

import diff_analysis
from traceback import format_exc

from angr.analyses.decompiler.structured_codegen.c import CVariable
from angr.sim_variable import *
from angr.sim_type import *
import tempfile
from IPython import embed

log = logging.getLogger(__name__)

C_IMPORTS = {
    'fopen': 'stdio.h',
    'fdopen': 'stdio.h',
    'freopen': 'stdio.h',
    'fclose': 'stdio.h',
    'fread': 'stdio.h',
    'fwrite': 'stdio.h',
    'malloc': 'stdlib.h',
    'free': 'stdlib.h',
    'calloc': 'stdlib.h',
    'realloc': 'stdlib.h',
    'reallocarray': 'stdlib.h',
    'fputc': 'stdio.h',
    'fputs': 'stdio.h',
    'putc': 'stdio.h',
    'putchar': 'stdio.h',
    'puts': 'stdio.h',
    'printf': 'stdio.h',
    'fprintf': 'stdio.h',
    'dprintf': 'stdio.h',
    'sprintf': 'stdio.h',
    'snprintf': 'stdio.h',
    'vprintf': 'stdarg.h',
    'vfprintf': 'stdarg.h',
    'vdprintf': 'stdarg.h',
    'vsprintf': 'stdarg.h',
    'vsnprintf': 'stdarg.h',
}

class AngrDecompiler(object):
    def __init__(self, artifacts_root, main_bin, proj, cfg, func, cc, max_steps, dec_type, start_time, metrics):
        self.artifacts_root = artifacts_root
        self.main_bin = main_bin
        self.bin_name = os.path.basename(main_bin)
        self.proj = proj
        self.cfg = cfg
        self.func = func
        self.cc = cc
        self.max_steps = max_steps
        self.dec_type = dec_type
        self.start_time = start_time
        self.metrics = metrics

        self.tmp_dir = tempfile.TemporaryDirectory()
        self.angr_dir = self.tmp_dir.name

    def prepare_decomp(self, decomp):
        """Prepare the decompiled C code generated by angr for recompilation.

        Specifically, the following changes are made:

        1. For any variable with multiple candidate data types, we pick one because
        gcc can't compile things like `int|short foo;`.

        Keyword Arguments:
        decomp -- The angr Decompiler object to prepare.

        Returns:
        None, decomp is modified directly.
        """
        mgr = decomp.kb.variables[decomp.func.addr]
        vars_in_use = decomp.codegen.cfunc.variables_in_use

        assigned_types = dict()
        for simvar, cvar in vars_in_use.items():
            if not isinstance(cvar, CVariable):
                continue

            if simvar.name in assigned_types:
                # this variable was previously assigned a type, change this
                # instance's type to match
                mgr.variable_to_types[simvar] = assigned_types[simvar.name]
            else:
                assigned_types[simvar.name] = cvar.variable_type

        # introduced in angr v9.2.0
        if hasattr(decomp.codegen, 'cexterns') and 'global' in decomp.kb.variables:
            assigned_types = dict()
            gmgr = decomp.kb.variables['global']
            for simvar, simtype in gmgr.variable_to_types.items():
                if simvar.name in assigned_types:
                    gmgr.variable_to_types[simvar] = assigned_types[simvar.name]
                else:
                    assigned_types[simvar.name] = simtype

        # regenerate code
        decomp.codegen.regenerate_text()

    def decompile_angr(self, cfg, func):
        """Decompile provided function, and also generate stubs for any called
        functions, so a C file can be generated that'll compile.

        Note that since the called functions will be stubs, the resulting C code
        will not produce the same behavior as the original program, but this is fine
        for analyzing just the parent function.

        For best results, all functions that were stubbed should be replaced with
        simprocs during angr analysis.

        Keyword Arguments:
        cfg -- The angr CFG the Function came from.
        func -- The angr Function to decompile.

        Returns:
        A tuple of the decompilation of func, a list of stubs, and a list of
        includes.
        """
        log.info("Decompiling function: %s" % func.name)
        decomp = cfg.project.analyses.Decompiler(
                func,
                cfg=cfg.model,
                variable_kb=cfg.kb
        )

        # clean up decompiled code
        self.prepare_decomp(decomp)

        # generate stubs
        includes = set()
        stub_names = set()
        stubs = list()
        for callee in func.functions_called():
            if callee.name in stub_names:
                # already generated stub
                continue

            if callee.name in C_IMPORTS:
                includes.add(C_IMPORTS[callee.name])
                continue
            #else:
            elif not isinstance(callee, type(None)) and not isinstance(callee.prototype, type(None)):
                c_str = callee.prototype.c_repr(name=callee.name)
                stubs.append("extern %s;" % c_str)

            stub_names.add(callee.name)

        # format includes
        includes = ["#include <%s>" % header for header in list(includes)]

        #iterate vars to put variables into metrics
        for simvar, cvar in decomp.codegen.cfunc.variables_in_use.items():
            if isinstance(simvar, SimMemoryVariable):
                if isinstance(cvar.variable_type, SimTypePointer):
                    self.metrics.total_vars += 1
                    self.metrics.pointer_vars += 1
                else:
                    self.metrics.total_vars += 1
                    self.metrics.non_pointer_vars += 1

        return (decomp, stubs, includes)


    def main_analysis(self):

        c_src_fp = os.path.join(self.angr_dir, 'decompiled.c')

        '''if os.path.exists(self.angr_dir):
            shutil.rmtree(self.angr_dir)
        
        utils.mkdir(self.angr_dir)'''

        ############################################################################################################################
        #################################################### Angr Decompilation ####################################################
        try:
            log.info("\n\n########## ANGR Decompilation ##########")

            includes = set()
            stubs = list()
            dec_time_start = datetime.now().timestamp()
            decomp, stubs, includes = self.decompile_angr(self.cfg, self.func)
            dec_time_end = datetime.now().timestamp()
            self.metrics.dec_time = dec_time_end - dec_time_start

            # generate final C source file
            c_text_angr = ""
            if len(includes) > 0:
                c_text_angr += "\n".join(includes) + "\n\n"
            if len(stubs) > 0:
                c_text_angr += "\n".join(stubs) + "\n\n"
            c_text_angr += decomp.codegen.text

            self.metrics.sloc = c_text_angr.count('\n')

            # write C source file
            with open(c_src_fp, 'w') as ofile:
                ofile.write(c_text_angr)
            log.info("Wrote decompiled C code to: %s" % c_src_fp)
            log.warning(c_text_angr)
            #################################################### Recompile Angr Output ####################################################
            recompiled_so_fp = os.path.join(self.angr_dir, 'decompiled.o')
            c_stdout, c_stdout_fp = utils.mksfile(self.angr_dir, 'w', 'stdout-')
            c_stderr, c_stderr_fp = utils.mksfile(self.angr_dir, 'w', 'stderr-')
            try:
                log.info("\n\n########## ANGR Recompilation ##########")
                check_bool = self.cc.compile(
                        [os.path.basename(c_src_fp)],
                        os.path.basename(recompiled_so_fp),
                        stdout=c_stdout,
                        stderr=c_stderr,
                        shared=True,
                        cwd=os.path.dirname(c_src_fp)
                )
                if not check_bool:
                    #print(check_bool)
                    shutil.copyfile(c_stderr_fp, os.path.join(self.artifacts_root, "std/angr", os.path.basename(self.main_bin).replace(".bin", "") + "+" + str(self.func.name)))
                    raise Exception("Recompilation failed with unkown reason")
                log.info("Successfully recompiled: %s" % recompiled_so_fp)
        
                #################################################### ANGR Differential Analysis ####################################################
                # differential analysis to determine whether the decompile is accurate
                try:
                    log.info("\n\n########## ANGR Differential Analysis ##########")
                    diff_mgr = diff_analysis.SymbolicDifferentialAnalysis(
                            self.bin_name,
                            self.proj,
                            self.cfg,
                            decomp,
                            self.func,
                            recompiled_so_fp,
                            "Angr",
                            self.angr_dir,
                            self.start_time,
                            self.metrics
                    )
                    log.info("Starting differential analysis")
                    try:

                        symbex_start_time = datetime.now().timestamp()
                        status, result, steps_taken, o_stashes, r_stashes = diff_mgr.analyze(self.func,
                                                                "ANGR", max_steps=self.max_steps)
                        symbex_end_time = datetime.now().timestamp()
                        self.metrics.get_stashes(o_stashes, r_stashes)
                        self.metrics.symbex_time = symbex_end_time - symbex_start_time
                        self.metrics.status = status
                        self.metrics.result = result
                        self.metrics.total_stepping = steps_taken

                    except KeyboardInterrupt:
                        log.warning("Keyboard interrupt")
                        #return EXIT_FAILURE
                    except Exception as ex:
                        self.metrics.status = 'Exception'
                        self.metrics.result = 'Diff-Analyze failed:' + str(ex)
                        log.error("Uncaught exception during differential analysis: %s" % str(ex))
                        log.error("Traceback: %s" % format_exc())
                        #return EXIT_FAILURE

                except KeyboardInterrupt:
                    log.warning("Keyboard interrupt")
                    #return EXIT_FAILURE
                except Exception as ex:
                    self.metrics.status = 'Exception'
                    self.metrics.result = 'Diff-Initialize failed:' + str(ex)
                    log.error("Failed to setup differential analysis: %s" % str(ex))
                    log.error("Traceback: %s" % format_exc())
                    #return EXIT_FAILURE


            except KeyboardInterrupt:
                log.warning("Keyboard interrupt")
                c_stdout.close()
                c_stderr.close()
                #return EXIT_FAILURE
            except Exception as ex:
                self.metrics.status = 'Exception'
                self.metrics.result = 'Recompilation failed:' + str(ex)
                log.error("Failed to compile decompiled code: %s" % str(ex))
                log.debug("Traceback: %s" % format_exc())
                log.error("See %s and %s in %s for details" % (
                        os.path.basename(c_stdout_fp),
                        os.path.basename(c_stderr_fp),
                        self.angr_dir))
                log.info("You can manually fix the source files in %s and restart from"
                        " here by rerunning the same command with --restart")

                self.cc.write_makefile(os.path.join(self.angr_dir, 'Makefile'), self.cc.last_cmd)
                log.info("A Makefile has been written to %s for debugging" % self.angr_dir)

                c_stdout.close()
                c_stderr.close()

                #return EXIT_FAILURE
        except KeyboardInterrupt:
            log.warning("Keyboard interrupt")
            #return EXIT_FAILURE
        except Exception as ex:
            self.metrics.status = 'Exception'
            self.metrics.result = 'Decompilation failed:' + str(ex)        
            log.error("Failed to decompile: %s" % str(ex))
            log.error("Traceback: %s" % format_exc())
            #return EXIT_FAILURE
        #Move artifacts to a permanent location
        artifacts_angr = os.path.join(self.artifacts_root, "angr")
        if os.path.exists(self.angr_dir):
            if not os.path.exists(os.path.join(artifacts_angr, os.path.basename(self.main_bin).replace(".bin", ""))):
                os.mkdir(os.path.join(artifacts_angr, os.path.basename(self.main_bin).replace(".bin", "")))
                shutil.move(self.angr_dir, os.path.join(artifacts_angr, os.path.basename(self.main_bin).replace(".bin", ""), str(self.func.name)))
            elif not os.path.exists(os.path.join(artifacts_angr, os.path.basename(self.main_bin).replace(".bin", ""), str(self.func.name))):
                shutil.move(self.angr_dir, os.path.join(artifacts_angr, os.path.basename(self.main_bin).replace(".bin", ""), str(self.func.name)))
            else:
                shutil.move(self.angr_dir, os.path.join(artifacts_angr, os.path.basename(self.main_bin).replace(".bin", ""), str(self.func.name) + "+v2"))

        #################################################### END OF ANGR ####################################################
